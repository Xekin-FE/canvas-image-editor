class Base {
    constructor(opt){
        this.x = opt.x
        this.y = opt.y
        this.zIndex = opt.zIndex //图层
        this.rotate = opt.rotate
        this.opacity = 1
    }
    
    mousedown(e){
        this.can.addEventListener('onmousemove',this.mousemove)
    }
    mousemove(e){
        this.can.addEventListener('onmouseup',this.mouseup)

    }
    mouseup(e){
        this.can.removeEventListener('onmousemove',this.mousemove)
        this.can.removeEventListener('onmouseup',this.mouseup)
    }
    dragUpdate(start, end){
        // 位置更新
    }
    scaleUpdate(start, end){
        // 缩放更新，角度处理
    }
    changeProperty(property, value){
        //一次操作只能更改一种属性
        this[property] = value;
        this.update()
    }
};

class Text extends Base{
    constructor(opt){
        super(opt)
        this.content = '点击编辑文字';
        this.font = '20px Arial';
        this.foWe = '400';
        this.foCo = '#fff';
        this.foFa = 'Microsoft Yahei' ;
        this.FiBg = false;
    }
    init(){
        ctx.font = this.font;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        let tw = ctx.measureText(this.content).width;
        let ftop = 3*can.height/4 -5;
        let fleft = can.width/2;
        ctx.rect(fleft-tw/2, ftop- 10, tw+20, 30);
        ctx.fillStyle= "#fff";
        ctx.strokeStyle='#fff';
        ctx.strokeText(this.content, fleft, ftop);
    }
    update(opt){

    }
    focus(e){
        // 判断是否在 Text 节点范围内，若是则打开编辑
    }
    
};
class CanvasBase {
    constructor(obj){
        this.author = 'Xekin'
        this.can = obj
        this.ctx = obj.getContext('2d')
    }
}
// Editor 返回最后的元素参数给 Canvas 绘制，Canvas 一旦绘制不可修改
// 一次次添加，所以每次只能添加一个对象
class Editor extends CanvasBase{
    constructor(obj){
        super(obj);
        this.text = new Text();
    }
    init(opt){
        
        this.can.height = opt.height;
        this.can.width = opt.width;
    }
    createText(input){
        input.addEventListener('input', this.text.update)
        this.can.addEventListener('onclick', this.text.focus);
        this.text.init();
    }
    returnParams(){
        // opt x, y, color, opacity, content, width, height
        this.can.removeEventListener('onclick', this.text.focus);
        this.ctx.clearRect(0, 0, this.can.width, this.can.height);
        
    }
}
class Canvas extends CanvasBase{
    constructor(obj){
        super(obj);
        this.img = new Image();
    }
    renderText(opt){
        let text = opt.contents;
        this.ctx.font = opt.font;
        this.ctx.textBaseline = 'middle';
        this.ctx.textAlign = 'center';
        this.ctx.strokeStyle='#fff';
        this.ctx.strokeText(text, opt.x, opt.y);
    }
    renderBgImage(src, editor, input){
        this.img.src = src;
        let maxHeight = 600;
        let maxWidth = 360;
        this.img.onload = () => {
            let imgwidth = this.img.width / this.img.height > 1 ? maxWidth : maxHeight/this.img.height*this.img.width;
            let imgheight = this.img.width / this.img.height > 1 ? maxWidth/this.img.width*this.img.height : maxHeight;
            editor.init({height:imgheight,width:imgwidth}, input)
            this.can.width = imgwidth;
            this.can.height = imgheight;
            this.ctx.drawImage(this.img, 0, 0, imgwidth, imgheight);
            this.ctx.save();
        }
    }
    saveImage(){
        return this.can.toDataURL();
    }
};